/**
 * New node file
 */

var globalStatusPim = []
var startTime = new Date();
console.log("started at "+startTime);
var util = require('util');


var assert = require('assert')

try
{
	var zmq = require('zmq');
}
catch(e)
{
	var l = "[root:ERROR] - No ZMQ support on this machine!"
	var f = function() { console.log(l); return { on : f, bindSync : f } }
	var zmq = {
		socket : f
	}
	f()
}


process.on('error', function(error) {
console.log('--> '+error) })

var sender = zmq.socket('push');
var receiver = zmq.socket('pull')
var http = require('http');
var url = require('url');
var jade = require('jade');
var mc = require('mc');
var os = require('os');
var binded = false;
var last_message_received;

/*
	execution_flag used so that if the message with a certain id is being processed,
	the controller will not kill the worker (since it is processing a message)
*/
var execution_flag = [];
var sending_protocol;

var TEST_LAST_MESSAGE_RECEIVED;
var TEST_CONSUMER;

//how much time passes from one message to the other
var AVG = 1000;

var idle_counter = 0;
var idle_max_timeout = 1000;
var kill_flag = false;
//TODO: change to variables, for now hardcoded
var options = {
	host: '127.0.0.1',
  	port: 9080,
  	method: 'PUT'
}

var connections = new Array()
var clients = new Array()
var dest = new Array()
var cb = undefined
var exit_manager = {}
var ta_manager = -1
var uid = undefined;
var proxy_connection;
var db_client = {};
var messages_sent = 0;
var messages_received = 0;
var isProducer = false;

var mc_cli = new mc.Client("agora.mobile.usilu.net:11211");

var fs = require('fs');

//DB stuff
try
{
	/*var Db = require('mongodb').Db,
  		Connection = require('mongodb').Connection,
  		Server = require('mongodb').Server;
	var host = process.env['MONGO_NODE_DRIVER_HOST'] != null ? process.env['MONGO_NODE_DRIVER_HOST'] : 'localhost';
	var port = process.env['MONGO_NODE_DRIVER_PORT'] != null ? process.env['MONGO_NODE_DRIVER_PORT'] : Connection.DEFAULT_PORT;
	var db = new Db('koala-state', new Server(host, port, {}), {safe: true, native_parser:true});
	db.open(function(err, client) {
		db_client = client;
	});*/
	var mongoose = require('mongoose');
	var db = mongoose.createConnection('localhost', 'test');
	var schema = mongoose.Schema({ k: 'String', val : "Number" });
	var Storage = db.model('Storage', schema);

}
catch(e)
{
	var l = "[root:ERROR] - No MONGODB support on this machine!"
	var f = function() { console.log(l); return { on : f, bindSync : f } }

	var db = {}
	this.state = {}
	//f()

}


assert(process.argv[2])
var port = process.argv[2]

/*
	Creates the server through the net library.
	Binds the connections to the server to execute
	a callback, if defined.
*/

 
connections.push(receiver)
if(exports.onbinding)
		exports.onbinding()

try {
receiver.on('message', function(data){

	var time = new Date().getTime();
	
	messages_received++;
	
	idle_counter = 0;
	
	//computing how much time since the last message received
	/*if(last_message_received){
		AVG += time - last_message_received;
		AVG = AVG / 2;
	}*/
	last_message_received = time;

	// try {	
		if(data.data) {
			data = JSON.parse(data.data);
		}
		// if(cb != undefined){
		// 	//console.log(JSON.parse(data.data).id)
		// 	if(data.msg){
		// 		//console.log("arrived id " +JSON.parse(data.msg).data.id); 
		// 		execution_flag[""+JSON.parse(data.msg).data.id] = true				
		// 		TEST_LAST_MESSAGE_RECEIVED = JSON.parse(data.msg);
		// 	}
		// 	else {
		// 		// console.log("arrived id " +JSON.parse(data.data));
		// 		execution_flag[""+JSON.parse(data.data).id] = true;			
		// 		TEST_LAST_MESSAGE_RECEIVED = JSON.parse(data.data);
		// 	}
			cb(data, uid);
		// }
		
	// }catch(e) {
	// 	console.log("error on the receiver in koala.js : " + e)		
	// }
});
}


catch (e ){ console.log("ERRORE in the try as a message is received in koala.js: " + e ) }

receiver.on("EINTR", function(e){
	console.log("EINTR error in koala.js receiver: " + e);
});

sender.on("EINTR", function(e){
	console.log("EINTR error in koala.js sender: " + e);
});

//console.log("ABOUT TO : receiver.bindSync to tcp://*: " + port);
//receiver listening from other nodes
try {
receiver.bindSync("tcp://*:" + port);
}
catch (e) {
	console.log("error during bindSync in koala.js : " + e);
}


exports.server = receiver
exports.connections = connections
exports.clients = clients
exports.state = {};



exports.setProducer = function(){
	isProducer = true;
}


exports.state.get = function(k, cb){
	//save in the db at key k the value val
	Storage.findOne({'k': k}, function(err, value) {
		return cb( value );
	});
}

exports.state.set = function(k, new_val){
	//save in the db at key k the value val
	Storage.findOne({'k': k}, function(err, key_value){
  		if (err) console.log("error in findOne in koala.js");
  		
  		if(key_value == null){
  			key_value = new Storage({k: k, val : new_val});
  		}
  		else {
  			key_value.val = new_val;
  		
  		}
  		
  		key_value.save(function(err) {
    		if (err) console.log("error when saving key_value in koala.js: " + err);
  		});
	});
}

/*
	State function to read the state of a val in mongodb
	@param {Object} k The koala object sending this to the DB
	@param {Object} val The value to be stored in the DB
*/
/*exports.state.get = function(k){
	//save in the db at key k the value val
	db.open(function(err, client) {
		client.collection('values', function(err, collection) {
			  collection.find({'k': k}, function(err, cursor) {
				cursor.toArray(function(err, items) {
            		db.close();
            		return items;
        		});
			});
		});
	});
}*/

/*
	State function to save the state in mongodb
	@param {Object} k The koala object sending this to the DB
	@param {Object} val The value to be stored in the DB
*/
/*exports.state.set = function(k, val){
	//save in the db at key k the value val
	db.open(function(err, client) {
		client.collection('values', function(err, collection) {
			collection.remove({'k': k}, function(err, r) {	
				collection.insert([{'k': k, 'val' : JSON.stringify(val)}], function(err, docs) {
            		db.close();
        		});
			});
		});
	});
}*/


/*
	Check function called from the scripts if they need to start only
	when the underlying stuff is binded. It may be used for example when
	we only want to start sending when the binding has been done. In
	that case the script will call this function and perform a send
	operation only if there is a binding from this node to somebody else.
*/
exports.isBinded = function(){
	return binded;
}


var idleInterval;
/*
	Assign the callback function of the "reply" given as
	parameter to the actual callback of the node.
	@param {function} func The callback function
*/
//UNCOMMENT IDLE INTERVAL, WAS COMMENTED ONLY FOR THE TESTS
exports.createNode = function(func, automatic) {
	console.log("CREATE NODE CALLED " + automatic);
	if(automatic === "true"){
		//idleInterval = setInterval(function() {console.log("idleInterval called!"); compute_idleness() }, idle_max_timeout);
	}
	cb = func

	return this;
}

/*
	Makes the state given as input observable by the
	outside through a node.js server.
	@param {Object} state The observable state
*/
var express = require('express');
var app = express();
app.set('view engine', 'jade');
app.set('views', __dirname + '/views');
var OBSERVERD_STATE = {};
var GLOBAL_KEY;

exports.makeObservable = function(state, path, cb) {
	//OBSERVED_STATE = state;
	
	app.get(path, function(req, res) {
		res.sendfile('/home/andrea/usi_liquid_streams/public/webcam_puzzle.html')
		// res.sendfile('/public/webcam_demo.html')
		//console.log(OBSERVED_STATE.length);
		
		/*
			GET FROM MEMCACHE AND OVERRIDE OBSERVED_STATE
		*/
		
		//console.log("in get of /puzzle");
		// mc_cli.connect(function() {
		// 	console.log("getting GLOBAL_KEY = " + GLOBAL_KEY);
		// 	mc_cli.get( GLOBAL_KEY, function(err, response) {
		// 		if(!err){
		// 			var parsed_result = JSON.parse(response[GLOBAL_KEY]);
					
		// 			//console.log(parsed_result);
		// 			res.render('observable.jade', {state : parsed_result.list, path: path});
					
		// 			//call callback with new user
		// 			cb(req);
		// 		}
		// 		else{
		// 			console.log("MC Library had an error on /puzzle:");
		// 			console.log(err);
		// 		}
		// 	});
		// });
	});
	
	/*
		REFRESH PATH
		Called from the AJAX request from the /puzzle page
	*/
	app.get(path+'/refresh', function(req, res){
		/*
			GET FROM MEMCACHE AND OVERRIDE OBSERVED_STATE
		*/
		// mc_cli.connect(function() {
		// 	console.log('lol')

		// 	mc_cli.get( GLOBAL_KEY, function(err, response) {
		// 		if(!err)
		// 			mc_cli.connect(function() {
						
		// 				OBSERVED_STATE = new Array();
						
		// 				var parsed_result = JSON.parse(response[GLOBAL_KEY]);

		// 				for(var i = 0; i < parsed_result.list.length; i++){
		// 					//iterate through all the connected ids and get the list of images
		// 					(function(i){
		// 					mc_cli.get( ""+parsed_result.list[i], function(err, response) {
							
		// 						if(err && err.type == 'NOT_FOUND'){
		// 							//nothing added yet!
		// 							console.log("nothing found for id = " + parsed_result.list[i]);
		// 							res.send([""]);
		// 							//console.log(err);
		// 						}
								
		// 						else if(!err){
		// 							//console.log("found something for id: " + parsed_result.list[i])
		// 							//console.log("iteration index : " + i + " OBSERVED_STATE.length before adding more stuff = " + OBSERVED_STATE.length)
									
		// 							//console.log(response);
									
		// 							var parsed_result_from_mc = JSON.parse(response[parsed_result.list[i]])
									
		// 							console.log("found in mc a result.length of " + parsed_result_from_mc.length + " for id = " + parsed_result.list[i]);
									
		// 							for(var j = 0; j < parsed_result_from_mc.length; j++){
		// 								OBSERVED_STATE.push(parsed_result_from_mc[j]);
		// 							}
									
									
									
		// 							//double check, the last element in the iter can't always be the last being returned from the db
		// 							if((i + 1) == parsed_result.list.length){
		// 								//console.log("situation in which parsed_result.list.legnth == " + (i + 1));
		// 								console.log("FINISH");
		// 								res.send(OBSERVED_STATE);
		// 							}
		// 						}
								
		// 						else{
		// 							console.log("error in retrieving state from other ids: ");
		// 							console.log(err);
		// 						}
								
		// 					});
		// 					})(i);
		// 				}
		// 			})
				
		// 		else{
		// 			console.log("error in getting the list of ids connected to the state");
		// 			console.log(err);
		// 		}
		// 	});
		// });
		//res.send(OBSERVED_STATE);

		res.send(globalStatusPim)
	});
	
	
	app.listen('6969'); 
}

/*
	Updates the state of the observable value
*/
exports.updateObservable = function(state) {
	globalStatusPim = state

	//memcache test
	// mc_cli.connect(function() {
	// 	mc_cli.set(uid, new Buffer(JSON.stringify(state)), { flags: 0, exptime: 0}, function(err, status) {
 //  			if (!err) { 
 //    			//console.log(status); // 'STORED' on success!
 //  			}
 //  			else {
 //  				console.log("MC Library had an error on updateObservable:");
 //  				console.log(err);
 //  			}
	// 	});
	// });
}

/*
	Set this as a particular cluster
*/
exports.createState = function(key) {
	GLOBAL_KEY = key;
}

setupState = function(key, flag){
mc_cli.connect(function() {
	mc_cli.gets( key, function(err, response) {
		if(err && err.type == 'NOT_FOUND'){
			//save myself
			mc_cli.connect(function() {
				console.log("creating the key " + key + " in memcache");
				var uidArray = {list: [uid]};
				mc_cli.add( key, new Buffer(JSON.stringify(uidArray)), { flags: 0, exptime: 0}, function(err, status) {
  					if (!err) { 
    					console.log(status + " in creating the array of uids and my uid is = " + uid); // 'STORED' on success!
  					}
  					else {
  						console.log("in not_found in createState with db error: " );
  						console.log(err);
  						setupState(key, true);
  					}
				});
			});
		}
		if (!err) {
			//save myself
			var parsed_result = JSON.parse(response[key].val);
			parsed_result.list.push(uid);
			mc_cli.cas( GLOBAL_KEY, new Buffer(JSON.stringify(parsed_result)), response[key].cas, { flags: 0, exptime: 0}, function(err, status) {
  				if (!err) { 
    				console.log(status + " in storing my uid in the array and my uid is = " + uid + "  with GLOBAL_KEY = " + GLOBAL_KEY); // 'STORED' on success!
  				}
  				else {
  					console.log("in !err of createState with error: ");
  					console.log(err);
  					setupState(key, true);
  				}
			});
		} 
		else {
			console.log("in createState with error in db : " + err.type);
  			console.log(err);
  		}
	});
	});
	
	if(!flag)
		mc_cli.connect(function() {
			//add my state to empty string
			mc_cli.add(uid, new Buffer("{}"), { flags: 0, exptime: 0}, function(err, status) {
  				if (!err) { 
    				console.log("add new empty state to the store with key my uid : " + uid) + " with status: " + status; // 'STORED' on success!
  				}
  				else {
  					console.log("error when adding own id as a key and empty state");
  					console.log(err);
  				}
			});
		});
}

/*
	Start the server by listening to the port.
*/
exports.start = function() {

	console.log(' --> listening '+port)
	
	//in theory listening to the port is done
	//as soon as the server is setup (in var server = ...) 
	//server.listen(port)
}

/*
	This function is called by the consumer and only by the consumer.
	It is used to tell the unerlying koala instance that it is done
	with the computation of a message. In this way koala is always aware
	when one of its consumers is busy or not and can decide if workers
	have to be added.
	@param: id - The id of the message received.
*/
exports.done = function(id){
	TEST_CONSUMER = true;
	messages_sent++;
	execution_flag[""+id] = false;
	
	/*
		AVG computed here, the avg was a wrong measure!!!
	*/
	
	idle_counter = 0;
	binded = true;
	
	if(last_message_received){
		var time = new Date().getTime();
		AVG = (time - last_message_received)/2;
	}
	
	return true;
}


/*
	General send function that takes as parameter the message to be sent. 
	The function calls the right send function given when the worker was instantiated. 
	The idea behind this function is to group all the common procedures
	that are done across all the send functions (e.g. checking if the node
	is binded or increasing the number of sent messages for the PID algorithm).
*/
exports.send = function(message, id){
	//console.log(exports.clients)
	
	if(exports.clients.length == 0){
		console.log("not a consumer, sending to something BUT no client to send to! ================================================================")
	}
		
	if(!binded){
		return;
	}
	
	messages_sent++;
	idle_counter = 0;
	execution_flag[""+id] = false;
	
	//message = JSON.stringify(message)
	
	/*
		AVG computed here, the avg was a wrong measure!!!
	*/
	if(last_message_received){
		var time = new Date().getTime();
		
		AVG = (time - last_message_received)/2;
		//console.log(AVG);
	}
	
	//If the sending protocol is not specified, then round_robin
	if(!sending_protocol)
		sending_protocol = 'round_robin';
	
	switch(sending_protocol){
		case undefined :
			console.log("no sending protocol received");
			break;
			
		case 'multicast':
			this.sendMC(message);
			break;
			
		case 'round_robin':
			this.send_LB(message);
			break;
			
		case 'send_LB_ID':
			this.send_LB_ID(message);
			break;
			
		case 'send_LB_Key':
			this.send_LB_Key(message);
			break;
		case '' :
			//called when there is no sending, just processing
			break;
		default :
			//nothing happens
			break;
	}
}


/*
	The send function takes care of sending messages to other nodes.
	TODO: The function takes care of the recipient of the message by
	checking if the connection is a websocket (remote_worker) or a
	normal socket.
	@param msg The message to send.
*/
exports.sendMC = function(message) {
	if(!binded)
		return;
	
	console.log("sendMC of uid = " + uid + " has clients.length = " + clients.length);
	
	exports.clients.map(function(c) {
		//console.log(util.inspect(c, true, 10, true));
		
		var ts = new Date().getTime();
	
		var msg = {
			data: message,
			from: uid,
			ts: ts,
		}
		
		try {
		if(c.sender['send']) {
			c.sender.send(JSON.stringify(msg))
		}
		else {
			c.sender.write(msg)
		}
		}
		catch (e ){ console.log("ERRORE in the catch of c.sender.send in sendMC function: " + e ) }	
	})
}


/*
	The send function takes care of sending messages to other nodes.
	TODO: The function takes care of the recipient of the message by
	checking if the connection is a websocket (remote_worker) or a
	normal socket.
	@param msg The message to send.
*/
exports.send_LB = function(message) {
	if(!binded)
		return;
	
	if(!exports.__i)
		exports.__i = Math.floor((Math.random() * exports.clients.length) + 1)
	
    exports.__i = exports.__i + 1
	
	var rand = exports.__i % exports.clients.length
	
	//console.log("send_LB in uid = " + uid + " with clients[rand] with value rand = " + rand);
	
    var c = exports.clients[ rand ]
    
    //CHECK ZMQ_POLLIN & ZMQ_POLLOUT
    //console.log("sender : " + c.sender.getsockopt(zmq.ZMQ_EVENTS) + " in id : " + uid);
	//console.log(zmq)
	
	if(!c) return
	
	var ts = new Date().getTime();
	
	var msg = {
		data: message,
		from: uid,
		ts: ts,
	}
	try {
	if(c.sender['send']) {
		//console.log("c.sender.send in uid " + uid + " with sender " + JSON.stringify(c.sender));
		c.sender.send(JSON.stringify(msg))
	}
	else {
		c.sender.write(msg)
	}	
	}
catch (e ){ console.log("ERRORE in send_LB function: " + e ) }	
}

var kount = 0;

exports.send_LB_ID = function(message) {
	if(!binded)
		return;
	
	if(!exports.__i)
		exports.__i = Math.floor((Math.random() * exports.clients.length) + 1)
	
    exports.__i = exports.__i + 1
	
	var rand = exports.__i % exports.clients.length
	
	//console.log("send_LB in uid = " + uid + " with clients[rand] with value rand = " + rand);
	
    var c = exports.clients[ rand ]

	if(!c) return
	
	var ts = new Date().getTime();
	
	var msg = {
		data: message.data,
		from: uid,
		ts: message.ts,
		msgid: kount++,
	}
	
	//console.log("msgid in send_lb_id = " + msg.msgid);
	try {
	if(c.sender['send']) {
		//console.log("c.sender.send in uid " + uid + " with sender " + JSON.stringify(c.sender));
		c.sender.send(JSON.stringify(msg))
	}
	else {
		c.sender.write(msg)
	}	
	}
catch (e ){ console.log("ERRORE in send_LB_ID function: " + e ) }	
}

/*
	The send function takes care of sending messages to other nodes.
	It uses a sort of sharding system.
	TODO: Merge with send_LB taking care if the message to send is 
	a key: value pair or not. If it's the case use this procedure,
	otherwise just randomly send to some receiver.
	@param {Object} object The message to send with {k: some_k, v: some_v}
						   and the entry v of the message is optional
*/
exports.send_LB_Key = function(m) {
	if(!binded)
		return;

	var k = uid;

	if(!dest[k]){
		//console.log("DEST NOT FOUND TAKING NEW ONE from clients with length " + exports.clients.length + " with i = " + exports.__i);
		var rand = Math.floor((Math.random() * exports.clients.length) + 1)
		//console.log("taking client at position " + rand);
		exports.__i = exports.__i + 1 || 0
		dest[k] = exports.clients[rand]
		if(exports.clients.length == 1 && rand == 1 && !dest[k]){
			dest[k] = exports.clients[0]
		}
		//dest[k] = exports.clients[0]
	}
	
	if(!dest[k]){
		console.log("still no dest[k] after creating one through modulo here in uid " + uid)
		return;
	}
	
	var ts = new Date().getTime();
	
	var msg = {
		data: m,
		from: uid,
		ts: ts,
	}
	try {
	if(dest[k].sender['send']) {
		//console.log("in " + uid + " sending to " + dest[k]);
		dest[k].sender.send(JSON.stringify(msg))
	}
	else {
		dest[k].sender.write(msg)
	}
	}
catch (e ){ console.log("ERRORE in send_LB_Key function: " + e ) }
}



/*
	Saves variables in koala_root with the same principle
	of the send() function.
*/
exports.runtime_register = function(msg) {

	//HTTP connection to koala_root
	options.path = '/API/vars?name='+msg.name+'&value=' + msg.value + '&pid=' + uid;
	http.request(options, function(res) {}).end()
	
	/*http.client.put( 'root.process.host/API/vars/' + msg.name + '?value=' + msg.value + '&pid=' + process.pid , function(){
		//some callback
	})*/
}


/*
	Saving an exit callback
*/
exports.exit_callback = function(ecm){
	exit_manager = ecm;
}

/*
	Write average
*/
exports.saveTime = function(average) {
	exit_manager.average = average; 
}

exports.saveTA = function(ta) {
	ta_manager = ta;
}


var t_a = new Array();
var count = 0;
exports.saveTimeArrival = function(time_arrival, counter, msgid){
	//console.log("saving");
	//t_a.push(""+time_arrival+";"+uid+";");
	//count = counter;
	
	/*fs.appendFile("/home/masiar/koala/koala/Koala/output/" + exit_manager.process + "ta"+ uid + ".txt", time_arrival+";"+msgid+";"+counter+";"+uid+'\n', function (err) {
	  	if (err) throw err;
		//  	console.log('The "data to append" was appended to file!');
	});	*/
}

exports.saveTimeDeparture = function(time_departure){

}

/*
	Opens a file and generates a stream of data. The cdBhunk callback is called for each data chunk, while 
	the cbEnd callback is called once the file has been entirely read.
*/
exports.openFileStream = function(filename, cbChunk, cbEnd) {

	function createLineReader(fileName) {
	
    	var EM = require("events").EventEmitter
    	var ev = new EM()
    	var stream = require("fs").createReadStream(fileName)
    	var remainder = null;
    	stream.on("data",function(data) {
        	if(remainder != null){//append newly received data chunk
            	var tmp = new Buffer(remainder.length+data.length)
    	       	remainder.copy(tmp)
	           	data.copy(tmp,remainder.length)
           		data = tmp;
        	}
        	var start = 0;
			for(var i=0; i<data.length; i++) {
				if(data[i] == 10){ //\n new line
					var line = data.slice(start,i)
	                ev.emit("line", line)
                	start = i+1;
				}
        	}
        	if(start<data.length) {
            	remainder = data.slice(start);
        	}
        	else {
            	remainder = null;
        	}
    	})

    	stream.on("end",function(){
        	if(null!=remainder) ev.emit("line",remainder)
        	ev.emit("end")
    	})

    	return ev
	}

	var lineReader = createLineReader(filename)
	lineReader.on('end', function() { cbEnd() })
	lineReader.on("line",function(d) { cbChunk(d) })	
}

/*
	Function that checks if there is something executing right now
*/
var isExecuting = function(flags){
	console.log(flags);
	for(var i = 0; i < flags.length; i++)
		if(flags[i] == true)
			return true;
	return false;
}


/*
	Takes care of the 'message' event. If the message is
	of type "bind" it creates a connection between the two
	entities.
	@param {function} The callback function to execute.
*/
process.on('message', function(msg) {

	// if(msg.command == 'bind_remote') {
	// 	remote_channel = msg.channel
	// 	binded = true
	// 	// K.send = channel.send

	// 	remote_channel.onmessage = function(message) {
	// 		cb(message)
	// 	}
	// }
	
	console.log("on message");
	//setup telling this process which process is it
	if(msg.command == 'setup'){
		uid = msg.uid;
		
		/*
		setupState(GLOBAL_KEY)
		*/
	}
	
	//prepare to shut down gracefully
	if(msg.command == 'kill'){
		
		/*console.log(exports.clients);
		console.log("last message received: " + last_message_received);
		console.log(" consumer? = " + TEST_CONSUMER)
		console.log(TEST_LAST_MESSAGE_RECEIVED);*/
		
		kill_flag = true;
		console.log("KILLING " + uid + " with last message received: " + last_message_received)
		var kill_interval = setInterval(function(proc_pid, c, last_message_received, receiver, zmq, execution_flag){
		
			var time_now = new Date().getTime();
			//if 10 seconds passed without receiving any message or no message received at all (producer or useless worker)
			//console.log(time_now + " - " + last_message_received + " > 10000 ? " + (time_now - last_message_received > 10000) + " " + !execution_flag);
			
			//console.log(execution_flag + " " + isExecuting(execution_flag));
			
			if(time_now - last_message_received > 10000 && !isExecuting(execution_flag) /*|| !last_message_received || receiver.getsockopt(zmq.ZMQ_EVENTS) | zmq.ZMQ_POLLIN == 0 && !isExecuting(execution_flag)*/){
				console.log("killing " + uid);
				//console.log("process id = " + proc_pid)
				
    			
    			var spawn = require('child_process').spawn;
				var n = spawn('kill', ['-9', ''+proc_pid]);
				
				clearInterval(kill_interval);
			}
		}, 1000, msg.proc_pid, exports.clients, last_message_received, receiver, zmq, execution_flag);
	}
	
	// Directly connect to the node
	if(msg.command == 'bind_node') {
		if(msg.host == 'agora') {
			msg.host = 'agora.mobile.usilu.net'
		}

		binded = true;
		sending_protocol = msg.protocol;
		
		if(msg.proxy && proxy_connection){
			//already existing connection to proxy, reuse the same
			console.log("ALREADY EXISTING CONNECTION TO PROXY");
			var sckt = {
				sender : proxy_connection.sender,
				from: msg.from,
				to: msg.to,
				sender_endpoint : proxy_connection.sender_endpoint,
			}
			exports.clients.push(sckt)
			process.send({cbid:msg.cbid})
			console.log('connected to '+msg.host+':'+msg.port)
			return
		}
		else {
			sender = zmq.socket('push');
			
			try {
				sender.connect("tcp://" + msg.host + ":" + msg.port, function(err) {
    				if (err) throw err;
				});
			}
			catch (e ){ 
				console.log("ERROR in bind_node, response: " + e ) 
			}
			
			if(msg.proxy){
				proxy_connection = {
					sender : sender,
					sender_endpoint: "tcp://" + msg.host + ":" + msg.port, 
				};
			}
			
			var sckt = {
				sender : sender,
				from: msg.from,
				to: msg.to,
				sender_endpoint : "tcp://" + msg.host + ":" + msg.port,
			}
			
			exports.clients.push(sckt)
			//console.log("in bind_node, from " + sckt.from + " to: " + sckt.to + " with exports.clients.length = " + exports.clients.length + " and content: " + JSON.stringify(exports.clients) + " and this uid = " + uid);
	
			//console.log('connected to '+msg.host+':'+msg.port)
		
			// Send back a message which will cause the callback "cbid" to be called
			process.send({cbid:msg.cbid})
		}
	}
	
	// Directly connect to the node
	if(msg.command == 'unbind_node') {

		/*
			Removes the binding from the socket to the worker. Iterates through the array of connections
			and when it finds the correct one it first disconnects the socket from that enpoint and then
			removes it from the array of clients (and then cleans the array from the leftover undefined).
		*/
	
		for(var i = 0; i < clients.length; i++){
			if(clients[i].from == msg.process_id && clients[i].to == msg.to_unbind){
				clients[i].sender.disconnect(""+clients[i].sender_endpoint);
				delete clients[i];
				clients = clean(clients, undefined);
			}
		}
		
		// Send back a message which will cause the callback "cbid" to be called
		process.send({cbid:msg.cbid});
	}
	
	// Connect to the remote worker (through the proxy)
	if(msg.command == 'bind_remote') {
		// console.log('binding remote')
		// console.log(msg)
		// remote_channel = msg.channel
		// binded = true
		// // K.send = channel.send


		// remote_channel.send('AAAH')
		// remote_channel.onmessage = function(message) {
		// 	cb(message)
		// }
	}

	if(msg.command == 'incoming_message') {
		cb(msg.message)
	}
	
	// Collect data about node messages sent (== node messages processed)
	if(msg.command == 'data_collect'){
		if(kill_flag)
			return;
			
			
		console.log("uid = " + uid + " data_collect message received!")
		
		
		//if(uid == 2) console.log("2 received => " + messages_received)
		process.send({
			response: "data_collect",
			data: messages_sent,
			rcvd : messages_received,
			index: msg.index,
			cluster : msg.cluster,
			exec_time : ta_manager,
			avg : AVG,
			ci : msg.ci,
		});
		
		//console.log("MESSAGE RECEIVED : " + messages_received + " MESSAGES_SENT " + messages_sent + " UID " + uid);
	}

	if(msg.command == "messages_sent") {

		// console.log("cpu usage of = "+getUsage(function(time) { console.log("USAGE: "+msg.uid+"= "+time+"%"); }));
			
		getUsage(function(time) {

			var now = new Date();

			process.send({
				cbid: msg.cbid,
				cid: msg.cid,
				wid: msg.uid,
				response: "messages_sent",
				messages_sent: messages_sent,
				messages_received: messages_received,
				uptime: now - startTime,
				cpu_usage: time
			});
		});

		
	}
})



/*
	Dealing with exit signal, saving whatever is
	passed to a file (hardcoded?)...
*/
process.on('SIGTERM', function() {
	//console.log(exit_manager.average);
	//process.exit(0)

	/*	
	//not the right node
	if(!exit_manager.process)
		process.exit();

	var final_ta;
	for(var i = 0; i < t_a.length; i++){
		final_ta += t_a[i] + "\n";
	}
	final_ta += count+"\n";
	
	fs.appendFile("/home/masiar/koala/koala/Koala/output/" + exit_manager.process + "ta.txt", final_ta + "\n", function(err) {
    	if(err) {
        	console.log(err);
        	process.exit();
    	}
    	process.exit();
	});*/
	 /*
	 fs.appendFile("/home/masiar/koala/Koala/output/messages.txt", exit_manager.average + "\n", function(err) {
    	if(err) {
        	console.log(err);
        	process.exit();
    	}
    	process.exit();
	});*/
	 
});


var clean = function(array, deleteValue) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] == deleteValue) {         
      array.splice(i, 1);
      i--;
    }
  }
  return array;
};


/*
	Graceful suicide handling for processes
*/

//setInterval(function() { kill_check() }, AVG);

var kill_check = function(){
	if(last_message_received < (new Date().getTime() - AVG) && isIdle()){
		graceful_kill();
		
		//this avoids calling twice graceful_kill()
		idle_counter = undefined;
	}
}

var graceful_kill = function(){
	clearInterval(idleInterval);
	
	console.log("graceful_kill");
	
	process.send({
		response: "graceful_kill",
		uid: uid,
	});
}

var isIdle = function(){
	if(idle_counter >= 5 )
		return true;
	else
		return false;
}

var compute_idleness = function(){
	//we check that its not the first value
	if(AVG != 1000)
		idle_max_timeout = (AVG / 5); // - (AVG / 10);
		
	//console.log(idle_max_timeout);
	
	clearInterval(idleInterval);
	idleInterval = setInterval(function() {compute_idleness() }, idle_max_timeout);
	
	//console.log("idle_counter = " + idle_counter + " in uid = " + uid + " and binded = " + binded);
	
	//console.log("my id : " + uid + " before binding"); 
	
	if(!binded)
		return;
		
	//console.log("my id : " + uid + " after binding"); 	
	console.log("====== checking for idleness : " + isIdle());
	if(isIdle()){
		graceful_kill();
	}
	else{
		idle_counter++;
	}
}


//start a timeout, in the callback a function that:
	//checks if the process has received messages in the last AVG time && if it's idle
		//kill()
	//otherwise renew timeout with AVG
	
//kill() function
	//tell koala_node intentions to kill -> which will tell root
	//expect graceful kill message
	//root should handle also the removal of a worker from the controller... [still todo]

/*
	Function to get the usage of the CPUs.
*/
var pcnt = 0;
var getUsage = function(cb){
    fs.readFile("/proc/" + process.pid + "/stat", function(err, data){
        var elems = data.toString().split(' ');
        var utime = parseInt(elems[13]);
        var stime = parseInt(elems[14]);
        cb(utime + stime);
    });
}

/*
//interval to control the cpu usage
setInterval(function(){
    getUsage(function(startTime){
        setTimeout(function(){
            getUsage(function(endTime){
                var delta = endTime - startTime;
                pcnt = 100 * (delta / 10000);

                if (pcnt > 20){
                    console.log("CPU Usage Over 20%!");
                }
            });
        }, 1000);
    });
}, 10000); */



