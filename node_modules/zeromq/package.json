{
  "name": "zeromq",
  "version": "0.0.1",
  "description": "zeromq for node.js",
  "main": "index",
  "repository": {
    "type": "git",
    "url": "http://github.com/JustinTulloss/zeromq.node.git"
  },
  "devDependencies": {
    "should": "0.3.1"
  },
  "engines": {
    "node": "0.4.x"
  },
  "contributors": [
    {
      "name": "Justin Tulloss",
      "email": "justin.tulloss@gmail.com",
      "url": "http://justin.harmonize.fm"
    },
    {
      "name": "Stéphan Kochen",
      "email": "stephan@kochen.nl",
      "url": "http://stephan.kochen.nl/"
    },
    {
      "name": "Mike Castleman",
      "email": "m@mlcastle.net",
      "url": "http://mlcastle.net/"
    },
    {
      "name": "Matt Crocker"
    },
    {
      "name": "Jeremy Barnes",
      "email": "jeremy@barneso.com",
      "url": "http://www.barneso.com/"
    },
    {
      "name": "Rick",
      "email": "technoweenie@gmail.com",
      "url": "http://techno-weenie.net/"
    },
    {
      "name": "Corey Jewett",
      "url": "http://syntheticplayground.com/"
    },
    {
      "name": "Micheil Smith",
      "email": "micheil@brandedcode.com",
      "url": "http://brandedcode.com/"
    },
    {
      "name": "TJ Holowaychuk",
      "email": "tj@vision-media.ca",
      "url": "http://tjholowaychuk.com/"
    }
  ],
  "readme": "This library gives you bindings to ØMQ from node.js. This is not terribly\nwell tested, but there is at least one company successfully using these bindings\nin production. Bug reports welcome.\n\nTo Install\n==========\n\nFirst, get [ØMQ 2.1], [Homebrew] on Mac will get you what you need.\nDebian/Ubuntu users may also need to install the `libev-dev` package.\n\nThen use [npm] to install zeromq.node:\n\n    $ npm install zmq\n\n`npm` will yell at you if you don't have node 0.3.0, as that is required.\n\nAPI\n===\n\nThe API contains elements of the [ØMQ API]. You should refer to it\nfor in depth detail of the expected behaviors of the system. These methods will\nnever return error codes, but may throw an exception if any of the errors\ndescribed in the ØMQ documentation occur.\n\nFirst, include the module:\n\n```js\nvar zmq = require('zmq');\n```\n\nAfter that, you can create sockets with:\n\n```js\nvar sock = zmq.socket('req');\n```\n\nUsing ØMQ sockets\n-----------------\nA socket is where the action happens. You can send and receive things and it is\noh such fun.\n\n#### Constructor - `function(type)`\n\n * type - A string describing the type of socket. You can read about the\n   different socket types [here][zmq_socket]. The name you use here matches the\n   names of the `ZMQ_*` constants, sans the `ZMQ_` prefix.\n\n#### Methods\n\n * connect(address) - Connect to another socket. `address` should be a string\n   as described in the [ØMQ API docs][zmq_connect]. This method is not\n   asynchronous because it is non-blocking. ØMQ will use the provided address\n   when it's necessary and will not block here.\n\n * bind(address, callback) - Bind to a socket to wait for incoming data.\n   `address` should be a string as described in the [ØMQ API docs][zmq_bind].\n   `callback` will be called when binding is complete and takes one argument,\n   which may be an `Error`, or simply `undefined` if everything's peachy.\n\n * send(message, ...) - `message` is a string to send across the wire. The\n   message is not sent immediately, but there is no callback indicating when\n   it has been transmitted. See the\n   [0MQ](http://www.zeromq.org/intro:read-the-manual) documentation for\n   [zmq_send](http://api.zeromq.org/2-1:zmq-send) for exact\n   transmission semantics. Raises an exception if the return is < 0.\n\n   The message must be a `Buffer` object or a string. It is assumed that\n   strings should be transmitted as UTF-8. If you provide more than one\n   argument to send, then a multipart ØMQ message will be sent.\n\n * close() - Closes the socket\n\n#### Socket Options\n\n   To set a socket option on a socket, use socket[property].  For example,\n\n   socket['identity'] = \"mainLoop\";\n\n   The following properties are available (the ZMQ_XXX constant describes the name in the ZeroMQ documentation available at [ØMQ setsockopt API]):\n\n   * ioThreadAffinity - set affinity for IO thread (integer, ZMQ_AFFINITY);\n   * backlog - set connection backlog for listening sockets (integer, ZMQ_BACKLOG);\n   * identity - set the socket identity (name) (string, ZMQ_IDENTITY);\n   * lingerPeriod - set the linger period in milliseconds (integer, -1 = unlimited, ZMQ_LINGER);\n   * receiveBufferSize - set the kernel receive buffer size (integer, 0 = OS default, ZMQ_RCVBUF);\n   * sendBufferSize - set the kernel receive buffer size (integer, 0 = OS default, ZMQ_RCVBUF);\n\n   The following apply to message buffering and reconnection:\n\n   * reconnectionInterval - set the time to wait between reconnection attempts in milliseconds (ZeroMQ attempts to reconnect broken connection automatically behind the scenes) (integer, ZMQ_RECONNECT_IVL)\n   * highWaterMark - set high water mark (in number of outstanding messages) before buffered messages start being dropped or swapped to disk (integer, zero = unlimited, ZMQ_HWM);\n   * diskOffloadSize - set the amount of disk swap space in bytes for buffering messages in case of disconnection (integer, ZMQ_SWAP)\n\n   The following options are applicable to multicast:\n\n   * multicastLoop - set whether multicast can go over loopback or not (boolean, ZMQ_MCAST_LOOP);\n   * multicastDataRate - set maximum multicast transmission rate in kbits per second (integer, ZMQ_RATE);\n   * multicastRecovery - set maximum multicast recovery interval in seconds (integer, ZMQ_RECOVERY_IVL)\n\n   The following properties are exposed but not normally used by client code (they are used internally by the library):\n\n   * _fd - File descriptor (integer, ZMQ_FD);\n   * _ioevents - Event loop used internally (ZMQ_EVENTS);\n   * _receiveMore - Message has more parts (boolean, ZMQ_RCVMORE);\n   * _subscribe - Subscribe to a channel (see subscribe() method) (string, ZMQ_SUBSCRIBE);\n   * _unsubscribe - Unsubscribe to a channel (see unsubscribe() method) (string, ZMQ_UNSUBSCRIBE);\n\n\n#### Events\n\n * message - A message was received. The arguments are the parts of the\n   message. So, for example, if you have an `xrep` socket with plain `req`\n   sockets on the other end, you can do something like:\n\n       socket.on('message', function(envelope, blank, data) {\n         socket.send(envelope, blank, compute_reply_for(data));\n       });\n\n * error - There was some error. The only argument is an `Error` object\n   explaining what the error was.\n\n\nTo Build\n========\n\n```\n$ make\n```\n\nTesting\n=======\n\n```\n$ make test\n```\n\nLicensing\n=========\n\nLicensed under the very permissive [MIT License].\n\n[node.js]: http://github.com/ry/node\n[npm]: https://github.com/isaacs/npm\n[ØMQ 2.1]: http://www.zeromq.org/intro:get-the-software\n[Homebrew]: http://mxcl.github.com/homebrew/\n[ØMQ API]: http://api.zeromq.org/\n[ØMQ setsockopt API]: http://api.zeromq.org/2-1-3:zmq-setsockopt\n[zmq_socket]: http://api.zeromq.org/zmq_socket.html\n[zmq_connect]: http://api.zeromq.org/zmq_connect.html\n[zmq_bind]: http://api.zeromq.org/zmq_bind.html\n[MIT license]: http://www.opensource.org/licenses/mit-license.php\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/JustinTulloss/zeromq.node/issues"
  },
  "homepage": "https://github.com/JustinTulloss/zeromq.node",
  "_id": "zeromq@0.0.1",
  "dist": {
    "shasum": "58e673d656d99b23d246c5f76c1a4b121c9c07bf"
  },
  "_from": "zeromq@",
  "_resolved": "https://registry.npmjs.org/zeromq/-/zeromq-0.0.1.tgz"
}
