#include <iostream>
#include <stdlib.h>

#include <Foundation/Foundation.h>
#include <IOKit/ps/IOPowerSources.h>
#include <IOKit/ps/IOPSkeys.h>

#include <node.h>
#include <v8.h>

using namespace v8;

int* getInfo(const void* key){

	CFTypeRef blob = IOPSCopyPowerSourcesInfo();
	CFArrayRef sources = IOPSCopyPowerSourcesList(blob);

	int size = CFArrayGetCount(sources);
	int* returnValue = (int*)malloc(sizeof(int) * size);

	CFDictionaryRef pSource = NULL;
	const void* psValue;

	// Prepend the size to the array.
	returnValue[0] = size;

	for(int i = 1; i <= size; i++){

		pSource = IOPSGetPowerSourceDescription(blob, CFArrayGetValueAtIndex(sources, i - 1));

		psValue = CFDictionaryGetValue(pSource, key);
		CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &returnValue[i]);
	}
	
	return returnValue;
}

Local<Array> arrayFromPointer(int* data){

	Local<Array> returnValue = Array::New(data[0]);

	for(int i = 0; i < data[0]; i++){

		returnValue -> Set(i, Number::New(data[i + 1]));
	}

	free(data);

	return returnValue;
}

Handle<Value> percentages(const Arguments& args){

	HandleScope scope;

	const void* maxKey = CFSTR(kIOPSMaxCapacityKey);
	const void* curKey = CFSTR(kIOPSCurrentCapacityKey);

	int* maxCapacity = getInfo(maxKey);
	int* curCapacity = getInfo(curKey);
	
	// First element is holding the size.
	int* percentages = (int*) malloc( sizeof(int) * (maxCapacity[0] + 1) );

	percentages[0] = maxCapacity[0];

	for(int i = 0; i < maxCapacity[0]; i++){
	
		percentages[i + 1] = ((float)curCapacity[i + 1] / (float)maxCapacity[i + 1]) * 100;
	}

	free(maxCapacity);
	free(curCapacity);

	// Call the callback function.
	Local<Function> callBack = Local<Function>::Cast(args[0]);
	Local<Value> argv[1] = {arrayFromPointer(percentages)};
	callBack -> Call(Context::GetCurrent() -> Global(), 1, argv);

	return scope.Close(Undefined());
}

Handle<Value> isCharging(const Arguments& args){

	HandleScope scope;

	const void* chargingKey = CFSTR(kIOPSIsChargingKey);

	int* chargingInfo = getInfo(chargingKey);

	// Call the callback function.
	Local<Function> callBack = Local<Function>::Cast(args[0]);
	Local<Value> argv[1] = {arrayFromPointer(chargingInfo)};
	callBack -> Call(Context::GetCurrent() -> Global(), 1, argv);

	return scope.Close(Undefined());
}

void init(Handle<Object> exports, Handle<Object> module){

	exports -> Set(String::NewSymbol("percentages"),
		FunctionTemplate::New(percentages) -> GetFunction());

	exports -> Set(String::NewSymbol("isCharging"),
		FunctionTemplate::New(isCharging) -> GetFunction());
}

NODE_MODULE(node_battery, init)